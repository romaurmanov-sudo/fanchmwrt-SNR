diff -urN a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
--- a/include/net/netfilter/nf_conntrack.h	2025-11-27 18:06:47.320384226 +0800
+++ b/include/net/netfilter/nf_conntrack.h	2025-11-27 18:00:39.169670577 +0800
@@ -72,6 +72,13 @@
 #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
 #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
 
+struct nf_fwx_data{
+	u32 mark;
+	u32 app_id;
+	u32 match_status;
+	u8 action;
+	u8 *host;
+};
 struct nf_conn {
 	/* Usage count in here is 1 for hash table, 1 per skb,
 	 * plus 1 for any connection(s) we are `master' for
@@ -121,6 +128,8 @@
 	/* Extensions */
 	struct nf_ct_ext *ext;
 
+	/*FanchmWrt Data*/
+	struct nf_fwx_data fwx_data;
 	/* Storage reserved for other modules, must be the last member */
 	union nf_conntrack_proto proto;
 };
diff -urN a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
--- a/net/netfilter/nf_conntrack_core.c	2025-11-27 18:06:38.992416159 +0800
+++ b/net/netfilter/nf_conntrack_core.c	2025-11-27 18:01:02.597598226 +0800
@@ -1655,6 +1655,12 @@
 	/* save hash for reusing when confirming */
 	*(unsigned long *)(&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev) = hash;
 	ct->status = 0;
+	/* fwx data */
+	ct->fwx_data.mark = 0;
+	ct->fwx_data.app_id = 0;
+	ct->fwx_data.match_status = 0;
+	ct->fwx_data.action = 0;
+	ct->fwx_data.host = NULL;
 	WRITE_ONCE(ct->timeout, 0);
 	write_pnet(&ct->ct_net, net);
 	memset_after(ct, 0, __nfct_init_offset);
